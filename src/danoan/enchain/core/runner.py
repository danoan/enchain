from dataclasses import dataclass
from collections import deque
import heapq
import copy
import subprocess
import types
from typing import Any, Dict, Generator, List, Optional,  Protocol, TextIO

############################
#  DAG
############################


class Node:
    def __init__(self, content: Any, id: int, label: Optional[str] = None):
        self.id = id

        self.content: Any = content
        self.label = label
        self.children: List[Node] = []

    def add(self, node: "Node") -> "Node":
        self.children.append(node)
        return self

    def __str__(self):
        return self.label


def create_node_factory():
    _next_id = 0

    def next_id() -> int:
        nonlocal _next_id
        _next_id += 1
        return _next_id

    def node_factory(content, label):
        return Node(content, next_id(), label)

    return node_factory

############################
#  DAG Views
############################


def in_out_view(n: Node):
    """
    Compute the in and out degree for each node in the graph.

    The result is compiled in a dictionary using the node ids
    as key values.

    {
        "id":
        {
            "in":set(),
            "out":set()
        }
    }
    """
    dict_view = {}

    def children(p: Node, c: Node):
        if p.id not in dict_view:
            dict_view[p.id] = {"in": set(), "out": set()}
        if c.id not in dict_view:
            dict_view[c.id] = {"in": set(), "out": set()}

        dict_view[p.id]["out"].add(c.id)
        dict_view[c.id]["in"].add(p.id)

    list(depth_traversal(n, children=children))

    return dict_view

############################
#  DAG Validator
############################


def has_cycle(n: Node) -> bool:
    """
    Check if a graph has a cycle.

    The nodes of the graph are visited in crescent order of
    its in-degree. Therefore, the first node to be visited is
    the root(s) of the graph with in-degree zero.

    At every visit, the visited node is removed and the graph
    adjacencies updated. If a visited node has an in-degree
    greater than zero, that indicates that the graph has a cycle.
    """
    view = in_out_view(n)
    heap = []
    node_finder = {}

    @dataclass(order=True)
    class HeapItem:
        in_degree: int
        node_id: int
        node: Dict[str, Any]

    def update_node_finder():
        for i, n in enumerate(heap):
            node_finder[n.node_id] = i

    def heap_item(k, v) -> HeapItem:
        return HeapItem(len(v["in"]), k, v)

    for k, v in view.items():
        heap.append(heap_item(k, v))

    while len(heap) != 0:
        heapq.heapify(heap)
        top_item = heapq.heappop(heap)
        update_node_finder()

        if top_item.in_degree != 0:
            break

        to_remove = []
        for out_id in top_item.node["out"]:
            heap_pos = node_finder[out_id]
            out_node = heap[heap_pos].node
            out_node["in"].remove(top_item.node_id)

            heap.append(heap_item(out_id, out_node))
            to_remove.append(heap_pos)

        to_remove.sort(reverse=True)
        [heap.pop(id) for id in to_remove]

    if len(heap) != 0:
        return True
    else:
        return False


############################
#  Traversals
############################


def depth_traversal(n: Node, pre=None, pos=None, terminal=None, children=None):
    """
    Generic depth traversal algorithm for directed graphs.

    One can have a pre-order traversal by passing the `pre` argument. Similarly,
    one can have a pos-order traversal by passing the `pos` argument. Root to
    leaf paths can generated by using the `terminal` argument.

    Args:
        pre: Function called before visiting children of current node.
        pos: Function called after visiting children of current node.
        terminal: Function called for leaf/terminal nodes.
        children: Function called before visiting each children of a node.
    """
    visited = set()

    def _depth_traversal(n: Node, pre=None, pos=None, terminal=None, children=None):

        if n in visited:
            return

        visited.add(n)
        if pre:
            r = pre(n)
            if isinstance(r, types.GeneratorType):
                yield from r

        if len(n.children) == 0 and terminal:
            r = terminal(n)
            if isinstance(r, types.GeneratorType):
                yield from r
        else:
            for c in n.children:
                if children:
                    children(n, c)
                yield from _depth_traversal(c, pre, pos, terminal, children)

        if pos:
            r = pos(n)
            if isinstance(r, types.GeneratorType):
                yield from r

    return _depth_traversal(n, pre, pos, terminal, children)


def pre_traversal(n: Node):
    """
    Return nodes of a graph in pre-order starting from the given node.
    """
    def pre(n: Node):
        yield n

    yield from depth_traversal(n, pre)


def pos_traversal(n: Node):
    """
    Return nodes of a graph in pos-order starting from the given node.
    """
    def pos(n: Node):
        yield n

    yield from depth_traversal(n, None, pos)


def single_path_traversal(n: Node):
    """
    Return all root-to-leaf paths in a graph.

    For cycles, no path is returned.
    """
    t = []

    def pre(n: Node):
        t.append(n)

    def pos(n: Node):
        t.pop()

    def terminal(n: Node):
        yield copy.deepcopy(t)

    yield from depth_traversal(n, pre, pos, terminal)


def print_path(p: List[Node]):
    return "->".join(str(n) for n in p)


############################
#  Content Producer
############################

class Producer(Protocol):
    """
    Abstraction of a chainable producer.

    Instances of this class can be chained together to create complex
    execution flows.

    Example:
        P1 -> P2
        P1.prepare( P2.prepare().read() ).read()
    """

    def read(self) -> str:
        """
        Return content produced by this instance.
        """
        ...

    def prepare(self, sources: Optional[List["Producer"]] = None, chain_exp: Optional[str] = None) -> "Producer":
        """
        Prepare producer input before producing content.
        """
        ...


class Application(Producer):
    """
    Specialized producer that generates contents from an executable.
    """

    def __init__(self, args: List[str]):
        self._args: List[str] = args

    def prepare(self, sources: Optional[List["Producer"]] = None, chain_exp: Optional[str] = None) -> "Application":
        # Extend the list of arguments by executing the
        # chain_exp over the source output
        for s in sources:
            s.read()
            # TODO: Apply the chain_exp
            pass
        return self

    def read(self) -> str:
        """
        TODO: Use streams
        """

        p = subprocess.run(self._args, capture_output=True, text=True)
        return p.stdout


class Library(Producer):
    """
    Specialized producer that generates contents from a function.
    """

    def __init__(self, fn):
        self._args = deque()
        self.fn = fn

    def prepare(self, sources: Optional[List["Producer"]] = None, chain_exp: Optional[str] = None) -> "Library":
        if not sources:
            return self

        for s in sources:
            self._args.append(s.read()["corrected"])
        return self

    def read(self) -> str:
        return self.fn(*self._args)


class Accumulator(Producer):
    """
    Specialized producer that accumulates its prepare arguments.
    """

    def __init__(self, args: List[str]):
        self._args = args

    def prepare(self, sources: Optional[List["Producer"]] = None, chain_exp: Optional[str] = None) -> "Accumulator":
        if not sources:
            return self

        for s in sources:
            self._args.extend(list(s.read()))
        return self

    def read(self) -> str:
        return self._args

############################
#  Runner
############################


class GraphComponent:
    def __init__(self, producers: List[Producer], chain_exp: str):
        self.producers: List[Producer] = producers
        self.chain_exp = chain_exp


def run_path(path: List[Node], first_result: Optional[List[str]] = None):
    """
    It is supposed to be called by a Flow only.

    A-B-C
        C-B-A
            C.prepare(B.prepare(A.prepare().read()))

    A-(B,C)-D
        D,(B,C),A
            D.prepare(
                      B.prepare(A.prepare().read()),
                      C.prepare(A.prepare().read())
                     ).read()
    """
    result = first_result
    for n in path:
        partial_result = []
        for p in n.content.producers:
            partial_result.append(p.prepare(result, n.content.chain_exp))
        result = copy.deepcopy(partial_result)

    assert len(result) == 1
    return result[0].read()


def run_graph(source: Node):
    """
    For test purposes only.
    """
    for p in single_path_traversal(source):
        yield (p, run_path(p))


class Flow(Producer):
    """
    A chain of producers.

    F1: A-B-C
    F2: A-D-E
    F3: (F1,F2) - G

    F4: [L1,L2] - (F1,F2) - H
    """

    def __parse_flow_string__(self, flow_string: str, symbols: Dict[str, Any]):
        factory = create_node_factory()
        nodes = flow_string.split("-")

        root = factory(None, "root")
        last = root
        for n in nodes:
            if n[0] == "(":
                subnodes = n[1:-1].split(",")
            else:
                subnodes = [n]

            producers = []
            chain_exp = ""
            for sn in subnodes:
                if sn not in symbols:
                    print(f"Symbol {sn} not found")
                    exit(1)
                producers.append(symbols[sn])
            gc = GraphComponent(producers, chain_exp)

            label = f"node-({','.join(subnodes)})"
            new_node = factory(gc, label)
            if last:
                last.add(new_node)
            last = new_node

        return root.children[0]

    def __init__(self, flow_string: str, symbols: Dict[str, Any]):
        self.flow = self.__parse_flow_string__(flow_string, symbols)
        self._args = []

    def read(self) -> str:
        p = list(single_path_traversal(self.flow))[0]
        return run_path(p, first_result=self._args)

    def prepare(self, sources: Optional[List["Producer"]] = None, chain_exp: Optional[str] = None) -> "Flow":
        self._args = []
        for s in sources:
            # TODO: Eventually apply the chain_exp in the sources
            self._args.append([s.read()])
        return self


@dataclass
class EnchainConfiguration:
    symbols: Dict[str, Any]


def parse_enchain_config(enchain_config: TextIO):
    return EnchainConfiguration({})


def engine(config: EnchainConfiguration):
    """
    Parse and execute an enchain config file.

    The enchain config file describes an execution flow. It 
    is an extension of yml.

    Here it is an example of an enchain configuration file:

    DATA:
        L1: input_to_json_file_1
        L2: input_to_json_file_2
    ALIAS:
        J1: jq_expression_1
        J2: jq_expression_2
    APP:
        A: PROG_A [0].[JQ_EXPR] [1].[JQ_EXPR]
        B: PROG_B [L2] [0].[J1] [1].[J2]
        C: PROG_C .[J1]
        D: PROG_D .[J2]
    FLOW:
        F1: A-(B,C)-D
        F2: (L1,L2)-C
    START:
        (F1,F2)-D

    The enchain configuration file is parsed into a list of symbols 
    and a start flow. To execute the program, one calls `start.read()` 
    """

    return config.symbols["start"].read()


def original_text():
    return "The music are playing and person are having fun"


def correct_text(original_text):
    return {"corrected": "The music is playing and people are having fun"}


def compare(t1, t2):
    result = []
    for w1, w2 in zip(t1.split(), t2.split()):
        if w1 != w2:
            result.append(
                {
                    "old": w1,
                    "new": w2
                }
            )
    return result


def explain_bold_terms(original_text):
    return {
        "music": "the acoustic result of a sequence of sounds obeying a certain rythm",
        "fun": "one has fun when is doing an activity they like"
    }


def test():
    """
    Real enchain example.

    APP:
        A: correct_text [INPUT]
        B: compare [INPUT] [0].corrected
        C: create_didactic_version [INPUT] [0].old [1].new
        D: explain_bold_terms [INPUT]
        E: cat [0].text [1].text
    FLOW:
        F1: A-B
        F2: F1-C
        F3: (F2,D)-E
    START:
        F3
    """

    L_correct_text = Library(lambda: correct_text(original_text()))
    L_compare = Library(lambda x: compare(original_text(), x))

    symbols = {
        "A": L_correct_text,
        "B": L_compare
    }

    F1 = Flow("A-B", symbols)
    print(F1.read())


############################
#  Tests
############################


def create_single_path():
    """
    t1 -> t2 -> t3
    """
    f1 = GraphComponent([Accumulator(["a"])], "")
    f2 = GraphComponent([Accumulator(["b"])], "")
    f3 = GraphComponent([Accumulator(["c"])], "")

    node_factory = create_node_factory()

    n1 = node_factory(f1, "n1")
    n2 = node_factory(f2, "n2")
    n3 = node_factory(f3, "n3")

    n2.children.append(n3)
    n1.children.append(n2)

    return n1


def create_multiple_path():
    """

    -------- t2     ---- t5
    |              |
    t1 ----- t3 -------- t6
    |
    -------- t4

    """
    f1 = GraphComponent([Accumulator(["a"])], "")
    f2 = GraphComponent([Accumulator(["b"])], "")
    f3 = GraphComponent([Accumulator(["c"])], "")
    f4 = GraphComponent([Accumulator(["d"])], "")
    f5 = GraphComponent([Accumulator(["e"])], "")
    f6 = GraphComponent([Accumulator(["f"])], "")

    node_factory = create_node_factory()

    n1 = node_factory(f1, "n1")
    n2 = node_factory(f2, "n2")
    n3 = node_factory(f3, "n3")
    n4 = node_factory(f4, "n4")
    n5 = node_factory(f5, "n5")
    n6 = node_factory(f6, "n6")

    n3.add(n5).add(n6)
    n1.add(n2).add(n3).add(n4)

    return n1


def create_sink_path():
    """

    -------- t2 --------
    |                  |
    t1 ----- t3 ------------ t5
    |                  |
    -------- t4 --------

    """
    f1 = GraphComponent(Accumulator(["a"]), "")
    f2 = GraphComponent(Accumulator(["b"]), "")
    f3 = GraphComponent(Accumulator(["c"]), "")
    f4 = GraphComponent(Accumulator(["d"]), "")
    f5 = GraphComponent(Accumulator(["e"]), "")

    node_factory = create_node_factory()

    n1 = node_factory(f1, "n1")
    n2 = node_factory(f2, "n2")
    n3 = node_factory(f3, "n3")
    n4 = node_factory(f4, "n4")
    n5 = node_factory(f5, "n5")

    n2.add(n5)
    n3.add(n5)
    n4.add(n5)
    n1.add(n2).add(n3).add(n4)

    return n1


def create_complex_flow():
    """

    -------- t2 --------
    |                  |
    t1 ----- t3 ------------ t5 --------
    |         |                        |
    |         -------------- t6 ------------ t7
    |                                  |
    -------- t4 ------------------------

    """
    f1 = GraphComponent(Accumulator(["a"]), "")
    f2 = GraphComponent(Accumulator(["b"]), "")
    f3 = GraphComponent(Accumulator(["c"]), "")
    f4 = GraphComponent(Accumulator(["d"]), "")
    f5 = GraphComponent(Accumulator(["e"]), "")
    f6 = GraphComponent(Accumulator(["f"]), "")
    f7 = GraphComponent(Accumulator(["g"]), "")

    node_factory = create_node_factory()

    n1 = node_factory(f1, "n1")
    n2 = node_factory(f2, "n2")
    n3 = node_factory(f3, "n3")
    n4 = node_factory(f4, "n4")
    n5 = node_factory(f5, "n5")
    n6 = node_factory(f6, "n6")
    n7 = node_factory(f7, "n7")

    n2.add(n5)
    n3.add(n5).add(n6)
    n4.add(n7)
    n5.add(n7)
    n6.add(n7)
    n1.add(n2).add(n3).add(n4)

    return n1


def create_cycle():
    """

    -------- t2 --------
    |                  |
    t1 ----- t3 ------------ t5 -- t1
    |                  |
    -------- t4 --------

    """
    f1 = GraphComponent(Accumulator(["a"]), "")
    f2 = GraphComponent(Accumulator(["b"]), "")
    f3 = GraphComponent(Accumulator(["c"]), "")
    f4 = GraphComponent(Accumulator(["d"]), "")
    f5 = GraphComponent(Accumulator(["e"]), "")

    node_factory = create_node_factory()

    n1 = node_factory(f1, "n1")
    n2 = node_factory(f2, "n2")
    n3 = node_factory(f3, "n3")
    n4 = node_factory(f4, "n4")
    n5 = node_factory(f5, "n5")

    n2.add(n5)
    n3.add(n5)
    n4.add(n5)
    n1.add(n2).add(n3).add(n4)
    n5.add(n1)

    return n1


def test_path(tree, paths):
    for ret, exp in zip(single_path_traversal(tree), paths):
        assert [str(n) for n in ret] == exp


def test_single_path_traversal_single_path():
    print("Test: Single Path")
    paths = [["n1", "n2", "n3"]]
    test_path(create_single_path(), paths)
    print("Passed")


def test_single_path_traversal_multiple_path():
    print("Test: Multiple Path")
    paths = [
        ["n1", "n2"],
        ["n1", "n3", "n5"],
        ["n1", "n3", "n6"],
        ["n1", "n4"]
    ]
    test_path(create_multiple_path(), paths)
    print("Passed")


def test_single_path_traversal_sink_path():
    print("Test: Sink Path")
    paths = [
        ["n1", "n2", "n5"],
        ["n1", "n3", "n5"],
        ["n1", "n4", "n5"],
    ]
    test_path(create_sink_path(), paths)
    print("Passed")


def test_cycle_traversal():
    print("Test: Cycle Traversal")
    g = create_cycle()
    assert len(list(single_path_traversal(g))) == 0
    print("Passed")


def test_run(run_generator, expected_values):
    for res, exp in zip(run_generator, expected_values):
        path, value = res
        assert value == exp


def test_run_single_path():
    print("Test: Run Single Path")
    n1 = create_single_path()
    test_run(run_graph(n1), [["c", "b", "a"]])
    print("Passed")


def test_run_multiple_path():
    print("Test: Run Multiple Path")
    n2 = create_multiple_path()
    expected_values = [
        ["b", "a"],
        ["e", "c", "a"],
        ["f", "c", "a"],
        ["d", "a"]
    ]
    test_run(run_graph(n2), expected_values)
    print("Passed")


def test_in_out_view():
    print("Test: InOut view ")
    g = create_complex_flow()
    view = in_out_view(g)
    expected = {
        1: {
            "in": set(),
            "out": set([2, 3, 4])
        },
        2: {
            "in": set([1]),
            "out": set([5])
        },
        3: {
            "in": set([1]),
            "out": set([5, 6])
        },
        4: {
            "in": set([1]),
            "out": set([7])
        },
        5: {
            "in": set([2, 3]),
            "out": set([7])
        },
        6: {
            "in": set([3]),
            "out": set([7])
        },
        7: {
            "in": set([4, 5, 6]),
            "out": set()
        },
    }
    for k, v in view.items():
        assert expected[k] == v
    print("Passed")


def test_check_cycle():
    print("Test Has Cycle")
    no_cycle = create_complex_flow()
    r_no_cycle = has_cycle(no_cycle)
    assert r_no_cycle is False

    cycle = create_cycle()
    r_cycle = has_cycle(cycle)
    assert r_cycle is True

    print("Passed")


def test_engine():
    """
    F1: A-B-C
    F2: A-D-E
    F3: (F1,F2) - G
    """

    print("Test: Engine")
    symbols = {
        "A": Accumulator(["A"]),
        "B": Accumulator(["B"]),
        "C": Accumulator(["C"]),
        "D": Accumulator(["D"]),
        "E": Accumulator(["E"]),
        "G": Accumulator(["G"]),
    }

    symbols["F1"] = Flow("A-B-C", symbols)
    symbols["F2"] = Flow("A-D-E", symbols)
    symbols["start"] = Flow("(F1,F2)-G", symbols)

    config = EnchainConfiguration(symbols)
    assert engine(config) == ["G", "C", "B", "A", "E", "D", "A"]
    print("Passed")


def main():
    test_single_path_traversal_single_path()
    test_single_path_traversal_multiple_path()
    test_single_path_traversal_sink_path()
    test_cycle_traversal()
    test_run_single_path()
    test_run_multiple_path()
    test_in_out_view()
    test_check_cycle()
    test_engine()

    test()


if __name__ == "__main__":
    main()
